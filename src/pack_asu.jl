"""
    pack_asu(points, N, T, ArrayType; shift=Tuple(zeros(length(N))))

Pack ASU points into dense blocks using a greedy rectangular decomposition.
"""
function pack_asu(points::Vector{ASUPoint}, N::Tuple, T::Type=Float64, ArrayType=Array; shift::NTuple=Tuple(zeros(Float64, length(N))))
    D = length(N)
    
    # 1. Group by Depth (blocks must share recursive depth/parity structure)
    depth_groups = Dict{Vector{Int}, Vector{ASUPoint}}()
    for p in points; push!(get!(depth_groups, p.depth, []), p); end
    
    blocks = ASUBlock{T, D, ArrayType{T,D}}[] # Preliminary type assumption (refined later)

    # 2. Greedy Packing per Group
    for (depth, group) in depth_groups
        sort!(group, by = p->p.idx)
        pool_indices = Set(p.idx for p in group)
        
        # Estimate strides: min non-zero diff per dimension
        strides = ones(Int, D)
        if length(group) > 1
            coords = hcat([p.idx for p in group]...)
            for d in 1:D
                vals = unique(sort(coords[d, :]))
                strides[d] = length(vals) > 1 ? gcd(diff(vals)) : 1
            end
        end

        pool = copy(group)
        while !isempty(pool)
            p_start = pool[1]
            start_idx = p_start.idx
            
            # Grow Box Heuristic
            current_shape = ones(Int, D)
            ranges = [start_idx[d]:strides[d]:start_idx[d] for d in 1:D] # Initial 1-point ranges
            
            for d in 1:D
                s = strides[d]
                steps = 0
                while true
                     # Check if next slice exists in pool
                     next_slice_idx = start_idx[d] + (steps+1)*s
                     check_ranges = copy(ranges)
                     check_ranges[d] = next_slice_idx:1:next_slice_idx # Check strict slice
                     
                     slice_valid = true
                     # Only check validity of points generated by extending CURRENT established face
                     # Refined logic: Iterating over the *face* we are extending.
                     # Dimensions < d have ranges established. Dims > d are single points.
                     
                     # Construct iterator for the check-face
                     check_iter_ranges = Any[ranges[k] for k in 1:D]
                     check_iter_ranges[d] = next_slice_idx:1:next_slice_idx
                     
                     if any(pt -> !(collect(pt) in pool_indices), Iterators.product(check_iter_ranges...))
                         break
                     end
                     steps += 1
                end
                
                ranges[d] = start_idx[d]:s:(start_idx[d] + steps*s)
            end
            
            # Create Block
            block_idx_iter = Iterators.product(ranges...)
            used = [collect(pt) for pt in block_idx_iter]
            
            dims = tuple(length.(ranges)...)
            data = ArrayType(zeros(T, dims)) # Allocate
            
            # Determine actual concrete type A for structure
            A_concrete = typeof(data)
            
            # Reconstruct correctly typed list if specific type needed?
            # We used generic list. Let's just push to a generic list and convert at end.
            push!(blocks, ASUBlock(data, convert(Vector{StepRange{Int,Int}}, ranges), depth))
            
            setdiff!(pool_indices, used)
            filter!(p -> p.idx in pool_indices, pool)
        end
    end

    # 3. Organize into Structure
    if isempty(blocks)
        A_final = ArrayType{T, D}
    else
        A_final = typeof(blocks[1].data)
    end
    
    dim_blocks = Dict{Int, Vector{ASUBlock{T, D, A_final}}}()
    for b in blocks
        # Re-wrap if type mismatch (e.g. initial list was generic)
        b_typed = ASUBlock(b.data, b.range, b.depth)
        eff_dim = count(r->length(r)>1, b.range)
        push!(get!(dim_blocks, eff_dim, []), b_typed)
    end
    
    return CrystallographicASU{D, T, A_final}(dim_blocks, shift)
end
